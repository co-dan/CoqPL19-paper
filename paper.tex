%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2019}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\usepackage{url}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}
\usepackage{multicol}
\usepackage{graphicx}

\input{listings-coq.tex}
%\usepackage{booktabs}   %% For formal tables:
%\usepackage{subcaption}


\newcommand{\N}{\mathbb{N}}

\begin{document}

%% Title information
\title{Reification of shallow-embedded DSL in Coq with automated verification}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


\author{Vadim Zaliva}
\affiliation{
  \institution{Carnegie Mellon University}
}
\email{vzaliva@cmu.edu}

\author{Matthieu Sozeau}
\affiliation{
  \institution{INRIA}
}
\email{mattam@mattam.org}


\begin{abstract}
  Shallow and deep embeddings have their pros and cons. For example
  shallow embedding is excellent for quick prototyping, as it allow
  quickly extend or modify the embedded language.  Meanwhile deep
  embedding is better suited for code transformation and compilation.
  Thus it might be useful to be able to switch from shallow to deep
  embedding while making sure the semantic of embedded language is
  preserved. We will demonstrate a working approach for implementing
  and proving such conversion using TemplateCoq.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{coq}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}

In the course of our work on HELIX system\cite{helixFHPC18} we faced
the problem of writing a certified compiler for domain specific
language called $\Sigma$-HCOL which is shallow-embedded in Gallina
language of Coq\cite{Coq} proof assistant.

The approach presented in this report is the result of summer 2018
collaboration visit to INRIA where the use of
TemplateCoq\cite{anand2018towards} first suggested by Matthieu Sozeau
and successfully implemented.

An application of this technique to reify $\Sigma$-HCOL could be found
in HELIX source code. For illustrative purposes in this paper we will
use a simpler language of arithmetic expressions on natural
numbers. It is shallow-embedded in Galina and includes constants,
bound variables, and three arithmetic operators: $+$, $-$, and
$*$. The complete source for which could be found in git repository
\url{https://github.com/vzaliva/CoqPL19-paper}.

\subsection{Example}

Provided, that $a, b, c, x \in \N$ below is an example of a valid
expression in source language:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize,
  caption=Expression in source language,
  label=lst:sexp]
2 + a*x*x + b*x + c.
\end{lstlisting}

The target language includes the same operators but will be defined by
an inductive type of it's AST:

\begin{lstlisting}[language=Coq, mathescape=true,
  caption=Target Language type
  frame=single,basicstyle=\footnotesize]
Inductive NExpr: Type :=
| NVar  : nat -> NExpr (* using Bruijn indices *)
| NConst: nat -> NExpr
| NPlus : NExpr -> NExpr -> NExpr
| NMinus: NExpr -> NExpr -> NExpr
| NMult : NExpr -> NExpr -> NExpr.
\end{lstlisting}

The expression from Listing~\ref{lst:sexp}, translated to the target
language looks like:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize,
  caption=Expression in target language, label=lst:texp]
NPlus (NPlus (NPlus (NConst 2)
  (NMult (NMult (NVar 3) (NVar 0)) (NVar 0)))
    (NMult (NVar 2) (NVar 0))) (NVar 1)
\end{lstlisting}

The purpose of the reification step is just to switch from shallow to
deep embedding. Thus the target language syntax is supposed to be
close to the source one. We just change the representation and
enforcing the scope of the shallow embedding, to ensure that only the
allowed subset of Gallina. This make translation implementation pretty
straightforward. Additionally, this allows automatic proof of semantic
preservation.

\section{Translation}

The translation process perform reification of a given expression,
producing an expression in the target language. It is implemented as a
\textit{template program} named \emph{reifyNExp}. It takes an
expression of arbitrary type (using \textit{universe polymorphism}
feature) and two names (as strings). The first name will be used as a
name of a new definition, to which expresion in the target language
will be bound. The second name will be a name of semantic preservation
lemma, discussed in the next section.

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize]
Polymorphic Definition reifyNExp@{t u}
  {A:Type@{t}}} (res_name lemma_name: string) (nexpr:A)
  : TemplateMonad@{t u} unit.
\end{lstlisting}

When executed, if succeeds, \emph{reifyNExp} will create a new
definition and lemma with given names or it will fail with an error.  The
reason for a failure might be if the expression contains constructs
which are legal in Gallina, but not part of our embedded language.

TODO: describe types of expressions we understand: (tLambda in
particular)

TODO: describe traversing Gallina AST

\section{Semantics Preservation}

The semantics of our source language is defined by Gallina. On the
other hand, the inductive type representing the target language needs
to be given a semantics associated with it. We do this by providing an
evaluation function. It takes an \textit{evaluation context} which
holds the current values of free variables, the expression being
evaluated, and returns the results of such evaluation as a natural
number or \emph{None} in case of error.

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize]
Definition evalContext:Type := list nat.
Fixpoint evalNexp ($\Gamma$:evalContext) (e:NExpr): option nat.
\end{lstlisting}

The evaluation may fail, for example, if the expression references a
variable not present in the evaluation context. As variables are
represented by their indices, this will happen if an index is greater
of equal than the length of the supplied list $\Gamma$.

The semantic preservation is expressed as a heterogeneous relation
between expressions in source and target languages:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize]
Definition NExpr_term_equiv ($\Gamma$: evalContext)
  (d: NExpr) (s: nat) : Prop := evalNexp $\Gamma$ d = Some s.
\end{lstlisting}

Consequently, for our example the lemma, generated by \emph{reifyNExp}
will state semantic equivalence between the two expressions from
Listing~\ref{lst:sexp} and Listing~\ref{lst:texp} respectively:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize]
forall x c b a : nat, NExpr_term_equiv [x; c; b; a]
    NPlus (NPlus (NPlus (NConst 2)
        (NMult (NMult (NVar 3) (NVar 0)) (NVar 0)))
        (NMult (NVar 2) (NVar 0))) (NVar 1)
    (2 + a * x * x + b * x + c)
\end{lstlisting}

The generated lemma still needs to be proven. Because the expressions
in the original and target languages have the same structure, such proof
could be automated. The general idea is to define and prove semantic
equivalence lemmas for each pair of operators and then add them as
hints into a hint database used with \emph{eauto} tactics:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize]
Lemma NExpr_add_equiv ($\Gamma$: evalContext) {a b a' b' }:
  NExpr_term_equiv $\Gamma$ a a' -> NExpr_term_equiv $\Gamma$ b b' ->
  NExpr_term_equiv $\Gamma$ (NPlus a b) (Nat.add a' b').

Lemma NExpr_mul_equiv ($\Gamma$: evalContext) {a b a' b' }:
  NExpr_term_equiv $\Gamma$ a a' -> NExpr_term_equiv $\Gamma$ b b' ->
  NExpr_term_equiv $\Gamma$ (NMult a b) (Nat.mul a' b').

Lemma NExpr_const_equiv ($\Gamma$: evalContext) {v v' }:
  evalNexp $\Gamma$ (NConst v) = Some v' ->
  NExpr_term_equiv $\Gamma$ (NConst v) v'.

Lemma NExpr_var_equiv ($\Gamma$: evalContext) {v x}:
  evalNexp $\Gamma$ (NVar v) = Some x ->
  NExpr_term_equiv $\Gamma$ (NVar v) x.

Create HintDb NExprHints.
Hint Resolve NExpr_add_equiv NExpr_mul_equiv: NExprHints.
Hint Resolve NExpr_const_equiv NExpr_var_equiv: NExprHints.

Obligation Tactic := intros; simpl; eauto 99 with NExprHints.
Run TemplateProgram (reifyNExp "Ex1_def" "Ex1_lemma" Ex1).
\end{lstlisting}

The ASTs of the original and translated expression and semantic
equivalence relations between them is shown on Figure~\ref{fig:trees}.

\begin{figure}[h]
  \label{fig:trees}
  \includegraphics[width=\columnwidth]{trees.eps}
  \caption{Semantics equivalence}
\end{figure}

\section{Summary}

Our approach could be summarized as follows. In order to translate a
language shallow-embedded in Gallina to the deep embedding complete
the following steps:

\begin{enumerate}
\item Define an inductive type for the target language AST.
\item Implement evaluation function for the target language.
\item Define a semantic equivalence relation between expressions in
  source and target languages.
\item Implement reification as template program which generates an
  expression in target language and semantic preservation lemma.
\item Define and prove lemmas of semantic equivalence between
  operators of source and target languages.
\item Define per-operator semantic equivalence lemmas and add them to
  hints database.
\item Apply this automation to prove automatically generated semantic
  preservation lemma.  
\end{enumerate}

%% Appendix
%\appendix
%\section{Appendix}


\nocite{*}
\bibliography{paper}

\end{document}

