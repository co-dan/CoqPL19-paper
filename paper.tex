%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2019}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations


\usepackage{url}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{color}

\input{listings-coq.tex}
%\usepackage{booktabs}   %% For formal tables:
%\usepackage{subcaption}


\newcommand{\N}{\mathbb{N}}

\begin{document}

%% Title information
\title{Reification of shallow-embedded DSL in Coq with automated verification}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Subtitle}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


\author{Vadim Zaliva}
\affiliation{
  \institution{Carnegie Mellon University}
}
\email{vzaliva@cmu.edu}

\author{Matthieu Sozeau}
\affiliation{
  \institution{INRIA}
}
\email{mattam@mattam.org}


\begin{abstract}
  Shallow and deep embeddings have their pros and cons. For example
  shallow embedding is excellent for quick prototyping, as it allow
  quickly extend or modify the embedded language.  Meanwhile deep
  embedding is better suited for code transformation and compilation.
  Thus it might be useful to be able to switch from shallow to deep
  embedding while making sure the semantic of embedded language is
  preserved. We will demonstrate a working approach for implementing
  and proving such conversion using TemplateCoq.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{coq}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{Introduction}

In the course of our work on HELIX system\cite{helixFHPC18} we faced
the problem of writing a certified compiled for domain specific
language $\Sigma$-HCOL shallow-embedded in Coq.

The approach presented in this report is the result of summer 2018
collaboration visit to INRIA where the use of
TemplateCoq\cite{anand2018towards} first suggested by Matthieu Sozeau
and successfully implemented.

While the actual application of this technique could be seen in HELIX
source code, for this paper we created a simpler example, the complete
source for which could be found at the following git repository:
\url{https://github.com/vzaliva/CoqPL19-paper}. In this example we use
a simple language of arithmetic expressions on type $\N$. Being
shallow-embedded in Galina it will include constants, pre-bound
variables, and three arithmetic operators: $+$, $-$, and $*$. The
expressions in target language have type $\N$. Provided, that
$a, b, c, x \in \N$ below is an example of a valid expression in this
language:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize,
  caption=Expression in source language,
  label=lst:sexp]
2 + a*x*x + b*x + c.
\end{lstlisting}

The target language will include the same operators but will be
defined by an inductive type of it's AST:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single,basicstyle=\footnotesize]
Inductive NExpr: Type :=
| NVar  : nat -> NExpr (* using Bruijn indices *)
| NConst: nat -> NExpr
| NPlus : NExpr -> NExpr -> NExpr
| NMinus: NExpr -> NExpr -> NExpr
| NMult : NExpr -> NExpr -> NExpr.
\end{lstlisting}

Our sample expression, translated to the target language should look
like:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize,
  caption=Expression in target language, label=lst:texp]
NPlus (NPlus (NPlus (NConst 2)
  (NMult (NMult (NVar 3) (NVar 0)) (NVar 0)))
    (NMult (NVar 2) (NVar 0))) (NVar 1)
\end{lstlisting}
   
\section{Translation}

The translation process will perform reification of given expression,
producing definitoin in the target language. It is implemented as a
\textit{template program} \emph{reifyNExp}. It is given an input
expression of arbitrary type (using \textit{universe polymorphism}
feature) and two names (as strings). The first name will be used as a
name of a new definition, to which expresion in the target language
will be bound. The second name will be a name of semantic preservation
lemma, discussed in the next section.

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize]
Polymorphic Definition reifyNExp@{t u}
  {A:Type@{t}}} (res_name lemma_name: string) (nexpr:A)
  : TemplateMonad@{t u} unit.
\end{lstlisting}

When executed, if succeeds, \emph{reifyNExp} will create the
definition and lemma with given names or fail with an error.  The
reason for a failure might be if the expression contains constructs
which are legal in Gallina, but not part of our embedded language.

\section{Semantics Preservation}

The semantics of our source language is defined by Gallina. On the
other hand, the inductive type representing the target language needs
to have a semantics associated with it. We do this by providing an
evaluation function. It takes an \textit{evaluation context} which
holds the current values of free variables, the expression being
evaluated, and returns the results of such evaluation as a natural
number or \emph{None} in case of error.

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize]
Definition evalContext:Type := list nat.
Fixpoint evalNexp ($\Gamma$:evalContext) (e:NExpr): option nat.
\end{lstlisting}

The evaluation may fail, for example, if the expression references a
variable not present in the evaluation context.

The semantic preservation is expressed as a heterogeneous relation
between valid expressions in source and target languages:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize]
Definition NExpr_term_equiv ($\Gamma$: evalContext)
  (d: NExpr) (s: nat) : Prop := evalNexp $\Gamma$ d = Some s.
\end{lstlisting}

Consequently, the lemma, generated by \emph{reifyNExp} will express
semantic equivalence between the two expressions:

\begin{lstlisting}[language=Coq, mathescape=true,
  frame=single, basicstyle=\footnotesize]
forall x c b a : nat, NExpr_term_equiv [x; c; b; a]
    NPlus (NPlus (NPlus (NConst 2)
        (NMult (NMult (NVar 3) (NVar 0)) (NVar 0)))
        (NMult (NVar 2) (NVar 0))) (NVar 1)
    (2 + a * x * x + b * x + c)
\end{lstlisting}


\section{Misc}
\begin{itemize}
\item Stripping Props
\item Target language could be a subset of original
\item From variable names to DeBruijn indices
\item Dealing with dependent types (\verb|TemplateMonad reifyResult| in HELIX)
\end{itemize}

\section{Future and Related work}
\begin{itemize}
\item From deep to shallow?
\item Generalizing as a framework
\end{itemize}

%% Bibliography
%\bibliography{bibfile}


%% Appendix
%\appendix
%\section{Appendix}


\nocite{*}
\bibliographystyle{acm}
\bibliography{paper}

\end{document}

