\documentclass{beamer}

\usepackage{pgfpages}
\setbeameroption{show notes on second screen=bottom}

\usepackage{url}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{color}
\usepackage[many]{tcolorbox}

\input{listings-coq.tex}

\newcommand{\N}{\mathbb{N}}
\newcommand{\ltac}{\mbox{$\mathcal{L}_{tac}$}}
\newcommand{\HCOL}{\emph{HCOL}}
\newcommand{\SHCOL}{\texorpdfstring{$\Sigma$-\emph{HCOL}}{Sigma-HCOL}}
\newcommand{\DHCOL}{\emph{D-HCOL}}
\newcommand{\FHCOL}{\emph{F-HCOL}}
\newcommand{\IHCOL}{\emph{I-HCOL}}

\usetheme{Madrid}
\usecolortheme{scott}
\useoutertheme{scott}
\setbeamertemplate{navigation symbols}{}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\title{Reification of shallow-embedded DSLs in Coq with automated verification}

\author{Vadim Zaliva \textsuperscript{1},Matthieu Sozeau \textsuperscript{2}}
\institute[A]{\textsuperscript{1}Carnegie Mellon University\\ %
\textsuperscript{2}Inria \& IRIF, University Paris 7
}

\date{CoqPL'19}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Shallow and Deep Embedding}
  There are several ways to embed a domain specific language (DSL) in
  a host language (HL):
  \medskip
  \begin{description}
  \item[Deep] DSL's AST is represented as HL data structures and
    semantic is explicitly assigned to it.
  \item[Shallow] DSL is a subset of HL and semantic is inherited from HL.
  \end{description}

  \medskip
  The shallow embedding is excellent for quick prototyping, as it
  allows quick extension or modification of the embedded language.
  Meanwhile, deep embeddings are better suited for code transformation
  and compilation.
  
\end{frame}

\begin{frame}{Motivation}

  HELIX system uses transformation and translation steps involving
  several intermediate languages:
  
  \begin{figure}
    \centering
    \includegraphics[keepaspectratio=true,width=0.96\paperwidth]{figures/lang_seq_to_dhcol.eps}
  \end{figure}

  {\SHCOL} language is shallow embedded, while {\DHCOL} is deep
  embedded. We were looking for a translation technique between the
  two which is:
  \medskip
  \begin{enumerate}
  \item Automated - Can automatically translate arbitrary valid
    {\SHCOL} expressions.
  \item Verified - Provides semantic preservation guarantees.
  \end{enumerate}

  \note[item]{{\SHCOL} and {\HCOL} are operator languages given
    denotational semantics and shallow embedding is convenient 
    representation for reasoning about them.}
  \note[item]{Translation validation is used for {\SHCOL} and
    {\HCOL} verification, while we develop a cerfified compiler from
    {\DHCOL} to LLVM IR}
  \note[item]{{\DHCOL} has only operational semantics}

\end{frame}

\begin{frame}[fragile]{An Example of Shallow Embedding in Coq}

  As an example let us consider a simple language of arithmetic
  expressions on natural numbers. It is shallow-embedded in Gallina
  and includes constants, bound variables, and three arithmetic
  operators: $+$, $-$, and $*$.
  
  \medskip
  Provided that $a, b, c, x \in \N$, the expression below is an
  example of a valid expression in the source language:
  \medskip
  \begin{lstlisting}[language=Coq, mathescape=true, basicstyle=\large,
    frame=single]
    2 + a*x*x + b*x + c.
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{An Example of Deep Embedding in Coq}

  A deep-embedded variant of the same language includes the same
  operators but will be defined by an inductive type of its AST:

  \begin{lstlisting}[language=Coq, mathescape=true,
    frame=single, basicstyle=\footnotesize]
    Inductive NExpr: Type :=
    | NVar  : nat -> NExpr (* using de Bruijn indices *)
    | NConst: nat -> NExpr
    | NPlus : NExpr -> NExpr -> NExpr
    | NMinus: NExpr -> NExpr -> NExpr
    | NMult : NExpr -> NExpr -> NExpr.
  \end{lstlisting}

  Our sample expression, in deep-embedded target language, looks like:
  
  \begin{lstlisting}[language=Coq, mathescape=true,
    basicstyle=\footnotesize, frame=single]
    NPlus (NPlus (NPlus (NConst 2)
      (NMult (NMult (NVar 3) (NVar 0)) (NVar 0)))
        (NMult (NVar 2) (NVar 0))) (NVar 1)
  \end{lstlisting}
  
\end{frame}

\begin{frame}{Template Coq}
  TBD
\end{frame}

\begin{frame}[fragile]{Reification Approach}
  
  \begin{itemize}
  \item Implemented as \textit{Template Program} named \emph{reifyNExp}
  \item The input expressions are given in a closed form, where all
    variables first need to be introduced via lambda
    bindings. E.g. $\mathbb{N}$ or
    $\N \rightarrow \ldots \rightarrow \N$.
  \item \emph{reifyNExp} also takes two names (as strings). The first
    is used as the name of a new definition, to which the expression
    in the target language will be bound. The second is the name to
    which the semantic preservation lemma will be bound.
  \end{itemize}

  \begin{lstlisting}[language=Coq, mathescape=true, frame=single]
  Polymorphic Definition reifyNExp@{t u}
    {A:Type@{t}} (res_name lemma_name: string) (nexpr:A)
    : TemplateMonad@{t u} unit.
  \end{lstlisting}

  When executed, if successful, \emph{reifyNExp} will create a new
  definition and new lemma with the given names. If not, it will fail
  with an error. \note{The reason for a failure might be that the
    expression contains constructs which are legal in Gallina but not
    part of our embedded language.}

\end{frame}

\begin{frame}{Semantic preservation}

\begin{figure}[h]
  \includegraphics[width=\columnwidth]{figures/trees.eps}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Questions?}

  Links:
  
  \begin{itemize}
  \item Full example: \url{https://github.com/vzaliva/CoqPL19-paper}
  \item TemplateCoq:
    \url{https://github.com/Template-Coq/template-coq/}
  \item \textit{``HELIX: a case
    study of a formal verification of high performance program
    generation.''}, Vadim Zaliva, Franz Franchetti. FHPC 2018. 
  \end{itemize}

  Contact:

  \begin{itemize}
  \item Vadim Zaliva: \url{http://www.crocodile.org/lord/}
  \item Matthieu Sozeau: \url{https://www.irif.fr/~sozeau/}
  \end{itemize}  
  
\end{frame}

\section{Backup slides}

\begin{frame}{From Denotational to Operational Semantics}
  \begin{center}
    \includegraphics[width=0.8\columnwidth]{figures/semantics.eps}
  \end{center}
  
  \begin{enumerate}
  \item {\SHCOL} has both denotational and operational semantics.
  \item Structural properties allow to switch from one to another.
  \end{enumerate}
  
\end{frame}


\end{document}
